[1mdiff --git a/Cargo.lock b/Cargo.lock[m
[1mindex 46fea25..f0a1352 100644[m
[1m--- a/Cargo.lock[m
[1m+++ b/Cargo.lock[m
[36m@@ -11,14 +11,6 @@[m [mdependencies = [[m
  "serde",[m
 ][m
 [m
[31m-[[package]][m
[31m-name = "kvdb"[m
[31m-version = "0.1.0"[m
[31m-dependencies = [[m
[31m- "bincode",[m
[31m- "serde",[m
[31m-][m
[31m-[m
 [[package]][m
 name = "proc-macro2"[m
 version = "1.0.103"[m
[36m@@ -37,6 +29,14 @@[m [mdependencies = [[m
  "proc-macro2",[m
 ][m
 [m
[32m+[m[32m[[package]][m
[32m+[m[32mname = "rust-kvdb"[m
[32m+[m[32mversion = "0.1.0"[m
[32m+[m[32mdependencies = [[m
[32m+[m[32m "bincode",[m
[32m+[m[32m "serde",[m
[32m+[m[32m][m
[32m+[m
 [[package]][m
 name = "serde"[m
 version = "1.0.228"[m
[1mdiff --git a/Cargo.toml b/Cargo.toml[m
[1mindex 84ffd84..8bdf410 100644[m
[1m--- a/Cargo.toml[m
[1m+++ b/Cargo.toml[m
[36m@@ -1,9 +1,8 @@[m
 [package][m
[31m-name = "kvdb"[m
[32m+[m[32mname = "rust-kvdb"[m
 version = "0.1.0"[m
[31m-edition = "2024"[m
[32m+[m[32medition = "2021"[m
 [m
 [dependencies][m
[31m-[m
 serde = { version = "1.0", features = ["derive"] }[m
[31m-bincode = "1.3"[m
\ No newline at end of file[m
[32m+[m[32mbincode = "1.3.3"[m
\ No newline at end of file[m
[1mdiff --git a/src/btree.rs b/src/btree.rs[m
[1mindex ba4e08b..9c36e78 100644[m
[1m--- a/src/btree.rs[m
[1m+++ b/src/btree.rs[m
[36m@@ -3,8 +3,8 @@[m [muse std::io::Error;[m
 use crate::pager::Pager;[m
 [m
 // Constantes da B-Tree[m
[31m-const T: usize = 3; [m
[31m-const MAX_KEYS: usize = 2 * T - 1; [m
[32m+[m[32mconst T: usize = 3;[m
[32m+[m[32mconst MAX_KEYS: usize = 2 * T - 1;[m
 [m
 #[derive(Serialize, Deserialize, Debug)][m
 pub struct BTree {[m
[36m@@ -14,8 +14,8 @@[m [mpub struct BTree {[m
 #[derive(Serialize, Deserialize, Debug)][m
 pub struct Node {[m
     pub keys: Vec<String>,[m
[31m-    pub values: Vec<String>,[m
[31m-    pub children: Vec<u64>, [m
[32m+[m[32m    pub values: Vec<Vec<u8>>,  // MODIFICADO: Vec<u8> em vez de String[m
[32m+[m[32m    pub children: Vec<u64>,[m
     pub is_leaf: bool,[m
     #[serde(skip)][m
     pub id: Option<u64>,[m
[36m@@ -26,13 +26,13 @@[m [mimpl BTree {[m
         BTree { root: None }[m
     }[m
 [m
[31m-    pub fn insert(&mut self, key: String, value: String, pager: &mut Pager) -> Result<(), Error> {[m
[32m+[m[32m    pub fn insert(&mut self, key: String, value: Vec<u8>, pager: &mut Pager) -> Result<(), Error> {[m
         if let Some(root_id) = self.root {[m
             let mut root_node = Node::load(root_id, pager)?;[m
 [m
             if root_node.keys.len() == MAX_KEYS {[m
                 let mut new_root = Node::new(false);[m
[31m-                new_root.children.push(root_id); [m
[32m+[m[32m                new_root.children.push(root_id);[m
                 [m
                 new_root.split_child(0, &mut root_node, pager)?;[m
 [m
[36m@@ -40,23 +40,20 @@[m [mimpl BTree {[m
                 [m
                 let mut child = Node::load(new_root.children[i], pager)?;[m
                 [m
[31m-                // CORRE√á√ÉO: Atualiza o ponteiro do filho modificado na nova raiz[m
                 new_root.children[i] = child.insert_non_full(key, value, pager)?;[m
 [m
                 self.root = Some(new_root.save(pager)?);[m
             } else {[m
[31m-                // CORRE√á√ÉO: A raiz mudou de lugar (append only), atualiza self.root[m
                 self.root = Some(root_node.insert_non_full(key, value, pager)?);[m
             }[m
         } else {[m
             let mut root_node = Node::new(true);[m
[31m-            // CORRE√á√ÉO: Captura o ID retornado[m
             self.root = Some(root_node.insert_non_full(key, value, pager)?);[m
         }[m
         Ok(())[m
     }[m
 [m
[31m-    pub fn search(&self, key: &str, pager: &mut Pager) -> Option<String> {[m
[32m+[m[32m    pub fn search(&self, key: &str, pager: &mut Pager) -> Option<Vec<u8>> {  // MODIFICADO: retorna Vec<u8>[m
         if let Some(root_id) = self.root {[m
             if let Ok(root_node) = Node::load(root_id, pager) {[m
                 return root_node.search(key, pager);[m
[36m@@ -66,7 +63,6 @@[m [mimpl BTree {[m
     }[m
 [m
     pub fn delete(&mut self, key: String, pager: &mut Pager) -> Result<(), Error> {[m
[31m-        // println!("DEBUG: BTree::delete chamado para chave '{}'", key);[m
         if let Some(root_id) = self.root {[m
             let mut root_node = Node::load(root_id, pager)?;[m
 [m
[36m@@ -85,6 +81,24 @@[m [mimpl BTree {[m
         }[m
         Ok(())[m
     }[m
[32m+[m
[32m+[m[32m    // M√©todos adicionais para persist√™ncia[m
[32m+[m[32m    pub fn load_from_pager(pager: &mut Pager) -> Result<Self, Error> {[m
[32m+[m[32m        if let Some(root_offset) = pager.get_root_offset() {[m
[32m+[m[32m            Ok(BTree {[m
[32m+[m[32m                root: Some(root_offset),[m
[32m+[m[32m            })[m
[32m+[m[32m        } else {[m
[32m+[m[32m            Ok(BTree::new())[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    pub fn save_to_pager(&self, pager: &mut Pager) -> Result<(), Error> {[m
[32m+[m[32m        if let Some(root_id) = self.root {[m
[32m+[m[32m            pager.set_root_offset(root_id)?;[m
[32m+[m[32m        }[m
[32m+[m[32m        Ok(())[m
[32m+[m[32m    }[m
 }[m
 [m
 impl Node {[m
[36m@@ -107,15 +121,14 @@[m [mimpl Node {[m
 [m
     pub fn save(&self, pager: &mut Pager) -> Result<u64, Error> {[m
         let mut data = self.to_bytes()?;[m
[31m-        data.resize(4096, 0); [m
[32m+[m[32m        data.resize(4096, 0);[m
         [m
[31m-        let offset = pager.get_end_offset()?; [m
[32m+[m[32m        let offset = pager.allocate_page()?;[m
         pager.write_at(offset, &data)?;[m
         Ok(offset)[m
     }[m
 [m
[31m-    // CORRE√á√ÉO CR√çTICA: Agora retorna Result<u64, Error> (o novo ID do n√≥)[m
[31m-    fn insert_non_full(&mut self, key: String, value: String, pager: &mut Pager) -> Result<u64, Error> {[m
[32m+[m[32m    fn insert_non_full(&mut self, key: String, value: Vec<u8>, pager: &mut Pager) -> Result<u64, Error> {[m
         let mut i = self.keys.len();[m
 [m
         if self.is_leaf {[m
[36m@@ -124,7 +137,6 @@[m [mimpl Node {[m
             }[m
             self.keys.insert(i, key);[m
             self.values.insert(i, value);[m
[31m-            // Retorna o novo ID gerado pelo save[m
             return self.save(pager);[m
         } else {[m
             while i > 0 && key < self.keys[i - 1] {[m
[36m@@ -142,22 +154,17 @@[m [mimpl Node {[m
                 }[m
                 let mut correct_child = Node::load(self.children[i], pager)?;[m
                 [m
[31m-                // CORRE√á√ÉO: O pai atualiza o ponteiro para o filho que mudou de lugar![m
                 self.children[i] = correct_child.insert_non_full(key, value, pager)?;[m
             } else {[m
[31m-                // CORRE√á√ÉO: O pai atualiza o ponteiro para o filho que mudou de lugar![m
                 self.children[i] = child.insert_non_full(key, value, pager)?;[m
             }[m
         }[m
[31m-        // Salva o pai (que agora tem ponteiros atualizados) e retorna seu novo ID[m
         self.save(pager)[m
     }[m
 [m
     fn split_child(&mut self, i: usize, child: &mut Node, pager: &mut Pager) -> Result<(), Error> {[m
         let mut right_node = Node::new(child.is_leaf);[m
 [m
[31m-        let _split_idx = T; [m
[31m-        [m
         let median_key = child.keys[T - 1].clone();[m
         let median_val = child.values[T - 1].clone();[m
 [m
[36m@@ -168,18 +175,16 @@[m [mimpl Node {[m
             right_node.children = child.children.drain(T..).collect();[m
         }[m
 [m
[31m-        child.keys.pop(); [m
[32m+[m[32m        child.keys.pop();[m
         child.values.pop();[m
 [m
[31m-        let new_left_id = child.save(pager)?; [m
[31m-        let right_id = right_node.save(